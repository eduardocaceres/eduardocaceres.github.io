<!doctype html><html lang=en-us><head><title>Snowflake Dynamic tables | The Simple Architect</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Data Architecture"><meta name=generator content="Hugo 0.148.2"><link rel=canonical href=https://eduardocaceres.github.io/posts/snowflakedynamictables/><link href=/css/style.min.5c1fa9bba2d0e854fe30b3d6316ab0114a2a5f25c9a98275badeadb66f2ec725.css rel=stylesheet></head><body><div class=flexWrapper><header class=headerWrapper><div class=header><div><a class=terminal href=/><span>dc@datahubstudio.io ~ $</span></a></div><input class=side-menu type=checkbox id=side-menu>
<label class=hamb for=side-menu><span class=hamb-line></span></label><nav class=headerLinks><ul><li><a href=https://eduardocaceres.github.io/about/ title>~/about</a></li><li><a href=https://eduardocaceres.github.io/blog/ title>~/blog</a></li><li><a href=https://eduardocaceres.github.io/posts/ title>~/posts</a></li></ul></nav></div></header><div class=content><main class=main><div class=postWrapper><h1>Snowflake Dynamic tables</h1><section class=postMetadata><dl><dt>published</dt><dd><time datetime=2025-08-18>August 18, 2025</time></dd><dt>reading time</dt><dd>2 minutes</dd></dl></section><div><p>What’s New with Snowflake Dynamic Tables</p><ol><li>Smarter Incremental Refreshes</li></ol><p>Snowflake’s fine-tuned the incremental engine driving Dynamic Tables. Snowflake updates the dynamic table with only the changes since the last refresh, making it ideal for large datasets with frequent small updates. Less data gets reprocessed, so refreshes are quicker and don’t hammer your warehouse as hard.</p><p>Why it matters: App devs get fresher data for UIs without lag spikes. Data scientists see faster updates for models. Data engineers save on compute costs.</p><ol start=2><li>Enhanced Downstream Lag
The TARGET_LAG = ‘DOWNSTREAM’ option — where refreshes kick off based on downstream needs — got an upgrade. It’s now sharper at handling chained Dynamic Tables (like one feeding another). Updates ripple through more smoothly when you’ve got dependencies.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>DYNAMIC</span> <span style=color:#66d9ef>TABLE</span> downstream_sales
</span></span><span style=display:flex><span> TARGET_LAG <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>‘</span>DOWNSTREAM<span style=color:#960050;background-color:#1e0010>’</span>
</span></span><span style=display:flex><span> WAREHOUSE <span style=color:#f92672>=</span> my_warehouse
</span></span><span style=display:flex><span><span style=color:#66d9ef>AS</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>SELECT</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>FROM</span> daily_sales_by_region <span style=color:#66d9ef>WHERE</span> total_sales <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>100</span>;
</span></span></code></pre></div><ol start=3><li>Better Monitoring Tools
The INFORMATION_SCHEMA.DYNAMIC_TABLE_REFRESH_HISTORY() view picked up new tricks, like REFRESH_TRIGGER columns. Pair that with tighter Resource Monitor integration, and you’ve got a clearer read on what’s eating your credits and why refreshes fire.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>SELECT</span> NAME, REFRESH_TRIGGER, <span style=color:#66d9ef>STATISTICS</span>, REFRESH_END_TIME
</span></span><span style=display:flex><span><span style=color:#66d9ef>FROM</span> <span style=color:#66d9ef>TABLE</span>(INFORMATION_SCHEMA.DYNAMIC_TABLE_REFRESH_HISTORY())
</span></span><span style=display:flex><span><span style=color:#66d9ef>WHERE</span> NAME <span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>‘</span>DAILY_SALES_BY_REGION<span style=color:#960050;background-color:#1e0010>’</span>;
</span></span></code></pre></div><p>Why it matters: Debug faster — spot if a refresh tanked from bad SQL or heavy data — and keep your budget in line.</p><ol start=4><li>Expanded Transformation Support
You can now throw more complex SQL into Dynamic Tables, like CTEs and subqueries. Recent updates (Q4 2024) loosened the old limits, so nested logic doesn’t trip you up as much.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>OR</span> <span style=color:#66d9ef>REPLACE</span> <span style=color:#66d9ef>DYNAMIC</span> <span style=color:#66d9ef>TABLE</span> sales_trends
</span></span><span style=display:flex><span>    TARGET_LAG <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;1 hour&#39;</span>
</span></span><span style=display:flex><span>    WAREHOUSE <span style=color:#f92672>=</span> my_warehouse
</span></span><span style=display:flex><span><span style=color:#66d9ef>AS</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WITH</span> ranked_sales <span style=color:#66d9ef>AS</span> (
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>SELECT</span> 
</span></span><span style=display:flex><span>            region,
</span></span><span style=display:flex><span>            sale_amount,
</span></span><span style=display:flex><span>            ROW_NUMBER() OVER (PARTITION <span style=color:#66d9ef>BY</span> region <span style=color:#66d9ef>ORDER</span> <span style=color:#66d9ef>BY</span> event_timestamp <span style=color:#66d9ef>DESC</span>) <span style=color:#66d9ef>AS</span> rn
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>FROM</span> sales_events
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>SELECT</span> region, sale_amount
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>FROM</span> ranked_sales
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>WHERE</span> rn <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span></code></pre></div><p>Why it matters: Data scientists can bake in ranking or trends. App devs get richer data without extra steps.</p><ol start=5><li>Warehouse Swaps on the Fly</li></ol><p>No need to rebuild a table to change its warehouse anymore. A quick ALTER lets you swap compute power as loads shift — handy when your refreshes start dragging.</p><p>ALTER DYNAMIC TABLE daily_sales_by_region SET WAREHOUSE = bigger_warehouse;
Why it matters: Data engineers can tweak performance without downtime — keeps things humming.</p></div></div></main></div><footer class=footer><span>© 2025 The Simple Architect, Built with
<a href=https://gohugo.io class=footerLink>Hugo</a> and
<a href=https://github.com/LordMathis/hugo-theme-nightfall class=footerLink>Nightfall</a> theme</span></footer></div></body></html>